<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · DataDeps.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DataDeps.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">DataDeps.jl Documentation</a></li><li><a class="toctext" href="z10-for-end-users.html">Usage for end-users</a></li><li><a class="toctext" href="z20-for-pkg-devs.html">Usage for developers (including researchers)</a></li><li><a class="toctext" href="z30-for-contributors.html">Extending DataDeps.jl for Contributors</a></li><li class="current"><a class="toctext" href="z40-apiref.html">API Reference</a><ul class="internal"><li><a class="toctext" href="#Public-API-1">Public API</a></li><li><a class="toctext" href="#Internal-1">Internal</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="z40-apiref.html">API Reference</a></li></ul><a class="edit-page" href="https://github.com/oxinabox/DataDeps.jl/blob/master/docs/src/z40-apiref.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>API Reference</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-Reference-1" href="#API-Reference-1">API Reference</a></h1><h2><a class="nav-anchor" id="Public-API-1" href="#Public-API-1">Public API</a></h2><pre><code class="language-docs">DataDep
ManualDataDep
register
@datadep_str
download</code></pre><h3><a class="nav-anchor" id="Helpers-1" href="#Helpers-1">Helpers</a></h3><pre><code class="language-docs">unpack</code></pre><h2><a class="nav-anchor" id="Internal-1" href="#Internal-1">Internal</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataDeps.DataDep" href="#DataDeps.DataDep"><code>DataDeps.DataDep</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DataDep(
    name::String,
    message::String,
    remote_path::Union{String,Vector{String}...},
    [checksum::Union{String,Vector{String}...},]; # Optional, if not provided will generate
    # keyword args (Optional):
    fetch_method=fetch_http # (remote_filepath, local_directory)-&gt;local_filepath
    post_fetch_method=identity # (local_filepath)-&gt;Any
)</code></pre><p><strong>Required Fields</strong></p><ul><li>*Name**: the name used to refer to this datadep, coresponds to a folder name where it will be stored<ul><li>It can have spaces or any other character that is allowed in a Windows filestring (which is a strict subset of the restriction for unix filenames).</li></ul></li><li><em>Message</em>: A message displayed to the user for they are asked if they want to downloaded it.<ul><li>This is normally used to give a link to the original source of the data, a paper to be cited etc.</li></ul></li><li><em>remote_path</em>: where to fetch the data from. Normally a string or strings) containing an URL<ul><li>This is usually a string, or a vector of strings (or a vector of vector... see <a href="Recursive Structure">Recursive Structure</a> below)</li></ul></li></ul><p><strong>Optional Fields</strong></p><ul><li><em>checksum</em> this is very flexible, it is used to check the files downloaded correctly<ul><li>By far the most common use is to just provide a SHA256 sum as a hex-string for the files</li><li>If not provided, then a warning message with the  SHA256 sum is displayed. This is to help package devs workout the sum for there files, without using an external tool.</li><li>If you want to use a different hashing algorithm, then you can provide a tuple <code>(hashfun, targethex)</code><ul><li><code>hashfun</code> should be a function which takes an IOStream, and returns a <code>Vector{UInt8}</code>.</li></ul></li></ul></li></ul><pre><code class="language-none">      - Such as any of the functions from [SHA.jl](https://github.com/staticfloat/SHA.jl), eg `sha3_384`, `sha1_512`
      - or `md5` from [MD5.jl](https://github.com/oxinabox/MD5.jl)</code></pre><ul><li>If you want to use a different hashing algorithm, but don&#39;t know the sum, you can provide just the <code>hashfun</code> and a warning message will be displayed, giving the correct tuple of <code>(hashfun, targethex)</code> that should be added to the registration block.</li></ul><pre><code class="language-none">- If you don&#39;t want to provide a checksum,  because your data can change pass in the type `Any` which will suppress the warning messages. (But see above warnings about &quot;what if my data is dynamic&quot;)
- Can take a vector of checksums, being one for each file, or a single checksum in which case the per file hashes are `xor`ed to get the target hash. (See [Recursive Structure](Recursive Structure) below)</code></pre><ul><li><p><code>fetch_method=fetch_http</code> a function to run to download the files.</p><ul><li>Function should take 2 parameters (remotepath, local_directory), and must return a local filepath</li><li>It is responsible for determining what the local filename should be</li><li>Change this to change the transfer protocol, for example to use an auth&#39;ed connection.</li><li>Default <code>fetch_http</code> is a wrapper around <code>Base.download</code> which invokes commandline download tools.</li><li>Can take a vector of methods, being one for each file, or a single method, in which case that method is used to download all of them. (See <a href="Recursive Structure">Recursive Structure</a> below)</li><li>Very few people will need to override this if they are just downloading public HTTP files. </li></ul></li><li><p><code>post_fetch_method</code> a function to run after the files have download</p><ul><li>Should take the local filepath as its first and only argument. Can return anything.</li><li>Default is to do nothing.</li><li>Can do what it wants from there, but most likes wants to extract the file into the data directory.</li><li>towards this end DataDeps includes a command: <code>unpack</code> which will extract an compressed folder, deleting the original.</li><li>It should be noted that it <code>post_fetch_method</code> runs from within the data directory<ul><li>which means operations that just write to the current working directory (like <code>rm</code> or <code>mv</code> or <code>run(`SOMECMD`))</code> just work.</li><li>You can call <code>cwd()</code> to get the the data directory for your own functions. (Or <code>dirname(local_filepath)</code>)</li></ul></li><li>Can take a vector of methods, being one for each file, or a single method, in which case that ame method is applied to all of the files. (See <strong>Recursive Structure</strong> in the README.md)</li></ul></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataDeps.ManualDataDep" href="#DataDeps.ManualDataDep"><code>DataDeps.ManualDataDep</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ManualDataDep(name, message)</code></pre><p>A DataDep for if the installation needs to be handled manually. This can be done via Pkg/git if you put the dependency into the packages repo&#39;s <code>/deps/data</code> directory. More generally, message should give instructions on how to setup the data.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataDeps.resolve-Tuple{AbstractString,Any}" href="#DataDeps.resolve-Tuple{AbstractString,Any}"><code>DataDeps.resolve</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">resolve(&quot;name/path&quot;, @__FILE__)</code></pre><p>Is the function that lives directly behind the <code>datadep&quot;name/path&quot;</code> macro. If you are working the the names of the datadeps programatically, and don&#39;t want to download them by mistake; it can be easier to work with this function.</p><p>Note though that you must include <code>@__FILE__</code> as the second argument, as DataDeps.jl uses this to allow reading the package specific <code>deps/data</code> directory. Advanced usage could specify a different file or <code>nothing</code>, but at that point you are on your own.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataDeps.resolve-Tuple{DataDeps.AbstractDataDep,Any,Any}" href="#DataDeps.resolve-Tuple{DataDeps.AbstractDataDep,Any,Any}"><code>DataDeps.resolve</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">resolve(datadep, inner_filepath, calling_filepath)</code></pre><p>Returns a path to the folder containing the datadep. Even if that means downloading the dependancy and putting it in there.</p><pre><code class="language-none"> - `inner_filepath` is the path to the file within the data dir
 - `calling_filepath` is a path to the file where this is being invoked from</code></pre><p>This is basically the function the lives behind the string macro <code>datadep&quot;DepName/inner_filepath&quot;</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataDeps.unpack-Tuple{Any}" href="#DataDeps.unpack-Tuple{Any}"><code>DataDeps.unpack</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">unpack(f; keep_originals=false)</code></pre><p>Extracts the content of an archive in the current directory; deleting the original archive, unless the <code>keep_originals</code> flag is set.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataDeps.@datadep_str-Tuple{Any}" href="#DataDeps.@datadep_str-Tuple{Any}"><code>DataDeps.@datadep_str</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">`datadep&quot;Name&quot;` or `datadep&quot;Name/file&quot;`</code></pre><p>Use this just like you would a file path, except that you can refer by name to the datadep. The name alone will resolve to the corresponding folder. Even if that means it has to be downloaded first. Adding a path within it functions as expected.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataDeps.DisabledError" href="#DataDeps.DisabledError"><code>DataDeps.DisabledError</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>DisabledError For when functionality that is disabled is attempted to be used</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataDeps.NoValidPathError" href="#DataDeps.NoValidPathError"><code>DataDeps.NoValidPathError</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>For when there is no valid location available to save to.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataDeps.UserAbortError" href="#DataDeps.UserAbortError"><code>DataDeps.UserAbortError</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>For when a users has selected to abourt</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.download-Tuple{DataDep,Any}" href="#Base.download-Tuple{DataDep,Any}"><code>Base.download</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Base.download(
    datadep::DataDep,
    localdir;
    remotepath=datadep.remotepath,
    skip_checksum=false,
    i_accept_the_terms_of_use=nothing)</code></pre><p>A method to download a datadep. Normally, you do not have to download a data dependancy manually. If you simply cause the string macro <code>datadep&quot;DepName&quot;</code>, to be exectuted it will be downloaded if not already present.</p><p>Invoking this <code>download</code> method manually is normally for purposes of debugging, As such it include a number of parameters that most people will not want to use.</p><ul><li><code>localdir</code>: this is the local directory to save to.</li><li><code>remotepath</code>: the remote path to fetch the data from, use this e.g. if you can&#39;t access the normal path where the data should be, but have an alternative.</li><li><code>skip_checksum</code>: setting this to true causes the checksum to not be checked. Use this if the data has changed since the checksum was set in the registry, or for some reason you want to download different data.</li><li><code>i_accept_the_terms_of_use</code>: use this to bypass the I agree to terms screen. Useful if you are scripting the whole process, or using annother system to get confirmation of acceptance.<ul><li>For automation perposes you can set the enviroment variable <code>DATADEPS_ALWAYS_ACCEPT</code></li><li>If not set, and if <code>DATADEPS_ALWAYS_ACCEPT</code> is not set, then the user will be prompted.</li><li>Strictly speaking these are not always terms of use, it just refers to the message and permission to download.</li></ul></li></ul><p>If you need more control than this, then your best bet is to construct a new DataDep object, based on the original,  and then invoke download on that.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataDeps._resolve-Tuple{DataDeps.AbstractDataDep,Any}" href="#DataDeps._resolve-Tuple{DataDeps.AbstractDataDep,Any}"><code>DataDeps._resolve</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>The core of the resolve function without any user friendly file stuff, returns the directory</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataDeps.accept_terms-Tuple{DataDep,Any,Any,Nothing}" href="#DataDeps.accept_terms-Tuple{DataDep,Any,Any,Nothing}"><code>DataDeps.accept_terms</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">accept_terms(datadep, localpath, remotepath, i_accept_the_terms_of_use)</code></pre><p>Ensurses the user accepts the terms of use; otherwise errors out.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataDeps.checksum-Tuple{Any,Any}" href="#DataDeps.checksum-Tuple{Any,Any}"><code>DataDeps.checksum</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">checksum(hasher=sha2_256, filename[/s])</code></pre><p>Executes the hasher, on the file/files, and returns a UInt8 array of the hash. xored if there are multiple files</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataDeps.checksum_pass-Tuple{Any,Any}" href="#DataDeps.checksum_pass-Tuple{Any,Any}"><code>DataDeps.checksum_pass</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">checksum_pass(hash, fetched_path)</code></pre><p>Ensures the checksum passes, and handles the dialog with use user when it fails.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataDeps.determine_save_path" href="#DataDeps.determine_save_path"><code>DataDeps.determine_save_path</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">determine_save_path(name)</code></pre><p>Determines the location to save a datadep with the given name to.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataDeps.ensure_download_permitted-Tuple{}" href="#DataDeps.ensure_download_permitted-Tuple{}"><code>DataDeps.ensure_download_permitted</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ensure_download_permitted()</code></pre><p>This function will throw an error if download functionality has been disabled. Otherwise will do nothing.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataDeps.env_bool" href="#DataDeps.env_bool"><code>DataDeps.env_bool</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">env_bool(key)</code></pre><p>Checks for an enviroment variable and fuzzy converts it to a bool</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataDeps.env_list" href="#DataDeps.env_list"><code>DataDeps.env_list</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">env_list(key)</code></pre><p>Checks for an enviroment variable and converts it to a list of strings, sperated with a colon</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataDeps.fetch_http-Tuple{Any,Any}" href="#DataDeps.fetch_http-Tuple{Any,Any}"><code>DataDeps.fetch_http</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">fetch_http(remotepath, localdir)</code></pre><p>Pass in a HTTP[/S] URL  and a directory to save it to, and it downloads that file, returing the local path. This is using the HTTP protocol&#39;s method of defining filenames in headers, if that information is present.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataDeps.get_filename-Tuple{Any}" href="#DataDeps.get_filename-Tuple{Any}"><code>DataDeps.get_filename</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">get_filename(remotepath)</code></pre><p>Given a remotepath (URL) returns the filename that it should be saved to locally.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataDeps.handle_missing-Tuple{DataDep,Any}" href="#DataDeps.handle_missing-Tuple{DataDep,Any}"><code>DataDeps.handle_missing</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">handle_missing(datadep::DataDep, calling_filepath)::String</code></pre><p>This function is called when the datadep is missing.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataDeps.input_bool" href="#DataDeps.input_bool"><code>DataDeps.input_bool</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bool_input</code></pre><p>Prompted the user for a yes or no.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataDeps.input_choice-Tuple{Any,Vararg{Char,N} where N}" href="#DataDeps.input_choice-Tuple{Any,Vararg{Char,N} where N}"><code>DataDeps.input_choice</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">input_choice</code></pre><p>Prompted the user for one of a list of options</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataDeps.input_choice-Tuple{Vararg{Tuple{Char,#s12,Any} where #s12&lt;:AbstractString,N} where N}" href="#DataDeps.input_choice-Tuple{Vararg{Tuple{Char,#s12,Any} where #s12&lt;:AbstractString,N} where N}"><code>DataDeps.input_choice</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">input_choice</code></pre><p>Prompts the user for one of a list of options. Takes a vararg of tuples of Letter, Prompt, Action (0 argument function)</p><p>Example:</p><pre><code class="language-none">input_choice(
    (&#39;A&#39;, &quot;Abort -- errors out&quot;, ()-&gt;error(&quot;aborted&quot;)),
    (&#39;X&#39;, &quot;eXit -- exits normally&quot;, ()-&gt;exit()),
    (&#39;C&#39;, &quot;Continue -- continues running&quot;, ()-&gt;nothing)),
)
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataDeps.is_valid_name-Tuple{Any}" href="#DataDeps.is_valid_name-Tuple{Any}"><code>DataDeps.is_valid_name</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">is_valid_name(name)</code></pre><p>This checks if a datadep name is valid. This basically means it must be a valid folder name on windows.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataDeps.list_local_paths-Tuple{String,Any}" href="#DataDeps.list_local_paths-Tuple{String,Any}"><code>DataDeps.list_local_paths</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">list_local_paths( name|datadep, [calling_filepath|module|nothing])</code></pre><p>Lists all the local paths to a given datadep. This may be an empty list</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataDeps.preferred_paths" href="#DataDeps.preferred_paths"><code>DataDeps.preferred_paths</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">preferred_paths(calling_filepath; use_package_dir=true)</code></pre><p>returns the datadeps load<em>path plus if calling</em>filepath is provided and <code>use_package_dir=true</code> and is currently inside a package directory then it also includes the path to the dataseps in that folder.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataDeps.process_header_filename-Tuple{RegexMatch}" href="#DataDeps.process_header_filename-Tuple{RegexMatch}"><code>DataDeps.process_header_filename</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">process_header_filename(raw)</code></pre><p>Deal with some of the weird and varied ways filenames can be given. Not full coverage, but getting the common cases.</p><p>Return nothing if input is nothing</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataDeps.run_checksum-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}" href="#DataDeps.run_checksum-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>DataDeps.run_checksum</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>If a vector of paths is provided and a vector of hashing methods (of any form) then they are all required to match.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataDeps.run_checksum-Tuple{AbstractString,Any}" href="#DataDeps.run_checksum-Tuple{AbstractString,Any}"><code>DataDeps.run_checksum</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Providing only a hash string, results in defaulting to sha2_256, with that string being the target</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataDeps.run_checksum-Tuple{Any,Any}" href="#DataDeps.run_checksum-Tuple{Any,Any}"><code>DataDeps.run_checksum</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>If only a function is provided then assume the user is a developer, wanting to know what hash-line to add to the Registration line.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataDeps.run_checksum-Tuple{Nothing,Any}" href="#DataDeps.run_checksum-Tuple{Nothing,Any}"><code>DataDeps.run_checksum</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>If <code>nothing</code> is provided then assume the user is a developer, wanting to know what sha2_256 hash-line to add to the Registration line.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataDeps.run_checksum-Tuple{Tuple{#s12,#s51} where #s51&lt;:AbstractString where #s12,Any}" href="#DataDeps.run_checksum-Tuple{Tuple{#s12,#s51} where #s51&lt;:AbstractString where #s12,Any}"><code>DataDeps.run_checksum</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">run_checksum(checksum, path)</code></pre><p>THis runs the checksum on the files at the fetched_path. And returns true or false base on if the checksum matchs. (always true if no target sum given) It is kinda flexible and accepts different kinds of behavour to give different kinds of results.</p><p>If path (the second parameter) is a Vector, then unless checksum is also a Vector, the result is the xor of the all the file checksums.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataDeps.run_checksum-Tuple{Type{Any},Any}" href="#DataDeps.run_checksum-Tuple{Type{Any},Any}"><code>DataDeps.run_checksum</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Use <code>Any</code> to mark as not caring about the hash. Use this for data that can change</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataDeps.run_fetch-Tuple{Any,Any,Any}" href="#DataDeps.run_fetch-Tuple{Any,Any,Any}"><code>DataDeps.run_fetch</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">run_fetch(fetch_method, remotepath, localdir)</code></pre><p>executes the fetch<em>method on the given remote</em>path, into the local directory and local paths. Performs in (async) parallel if multiple paths are given</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataDeps.run_post_fetch-Tuple{Any,Any}" href="#DataDeps.run_post_fetch-Tuple{Any,Any}"><code>DataDeps.run_post_fetch</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">run_post_fetch(post_fetch_method, fetched_path)</code></pre><p>executes the post<em>fetch</em>method on the given fetched path, Performs in (async) parallel if multiple paths are given</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataDeps.safer_joinpath-Tuple{Any,Vararg{Any,N} where N}" href="#DataDeps.safer_joinpath-Tuple{Any,Vararg{Any,N} where N}"><code>DataDeps.safer_joinpath</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">safer_joinpath(basepart, parts...)</code></pre><p>A variation on <code>joinpath</code>, that is more resistant to directory traveral attack The parts to be joined (excluding the <code>basepart</code>), are not allowed to contain <code>..</code>, or begin with a <code>/</code>. If they do then this throws an <code>DomainError</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataDeps.splitpath-Tuple{AbstractString}" href="#DataDeps.splitpath-Tuple{AbstractString}"><code>DataDeps.splitpath</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">splitpath(path)</code></pre><p>The opposite of <code>joinpath</code>, splits a path unto each of its directories names / filename (for the last).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataDeps.try_determine_load_path-Tuple{String,Any}" href="#DataDeps.try_determine_load_path-Tuple{String,Any}"><code>DataDeps.try_determine_load_path</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">try_determine_load_path(name)</code></pre><p>Trys to find a local path to the datadep with the given name. If it fails then it returns nothing.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataDeps.try_determine_package_datadeps_dir-Tuple{Any}" href="#DataDeps.try_determine_package_datadeps_dir-Tuple{Any}"><code>DataDeps.try_determine_package_datadeps_dir</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">try_determine_package_datadeps_dir(filepath)</code></pre><p>Takes a path to a file. If that path is in a package&#39;s folder, Then this returns a path to the deps/data dir for that package (as a Nullable). Which may or may not exist. If not in a package returns null</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataDeps.try_get_filename-Tuple{Any}" href="#DataDeps.try_get_filename-Tuple{Any}"><code>DataDeps.try_get_filename</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">try_get_filename(url)</code></pre><p>Uses as HEAD request, to attempt to retrieve the filename from the HTTP headers. Returns a string or nothing if it failes</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataDeps.uv_access-Tuple{Any,DataDeps.AccessMode}" href="#DataDeps.uv_access-Tuple{Any,DataDeps.AccessMode}"><code>DataDeps.uv_access</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">uv_access(path, mode)</code></pre><p>Check access to a path. Returns 2 results, first an error code (0 for all good), and second an error message. https://stackoverflow.com/a/47126837/179081</p></div></div></section><footer><hr/><a class="previous" href="z30-for-contributors.html"><span class="direction">Previous</span><span class="title">Extending DataDeps.jl for Contributors</span></a></footer></article></body></html>
